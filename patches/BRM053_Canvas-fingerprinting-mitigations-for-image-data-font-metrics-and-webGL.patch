From: csagan5 <32685696+csagan5@users.noreply.github.com>
Date: Sat, 24 Mar 2018 05:18:03 +0100
Subject: Canvas: fingerprinting mitigations for image data, font metrics and
 webGL

Disable webGL renderering info, add shuffling to TextMetrics;
additionally the color data returned by ToBlob and ToDataURL will
contain randomly manipulated pixels (maximum 6) that slightly
change the color R,G,B components without visibly altering the rendering.
---
 .../renderer/core/html/canvas/text_metrics.cc      |  20 +++
 .../blink/renderer/core/html/canvas/text_metrics.h |   2 +
 .../core/offscreencanvas/offscreen_canvas.cc       |   1 +
 .../canvas/canvas2d/base_rendering_context_2d.cc   |   3 +
 .../canvas/canvas2d/canvas_rendering_context_2d.cc |   6 +-
 .../modules/webgl/webgl_debug_renderer_info.cc     |   4 +-
 .../platform/graphics/image_data_buffer.cc         | 136 +++++++++++++++++++++
 .../renderer/platform/graphics/image_data_buffer.h |   2 +
 8 files changed, 171 insertions(+), 3 deletions(-)

diff --git a/third_party/blink/renderer/core/html/canvas/text_metrics.cc b/third_party/blink/renderer/core/html/canvas/text_metrics.cc
--- a/third_party/blink/renderer/core/html/canvas/text_metrics.cc
+++ b/third_party/blink/renderer/core/html/canvas/text_metrics.cc
@@ -47,6 +47,26 @@ float TextMetrics::GetFontBaseline(const TextBaseline& text_baseline,
   return 0;
 }
 
+void TextMetrics::Shuffle(const double amt) {
+  double adjusted = 1 + amt;
+
+  // x-direction
+  width_ *= adjusted;
+  actual_bounding_box_left_ *= adjusted;
+  actual_bounding_box_right_ *= adjusted;
+
+  // y-direction
+  font_bounding_box_ascent_ *= adjusted;
+  font_bounding_box_descent_ *= adjusted;
+  actual_bounding_box_ascent_ *= adjusted;
+  actual_bounding_box_descent_ *= adjusted;
+  em_height_ascent_ *= adjusted;
+  em_height_descent_ *= adjusted;
+  hanging_baseline_ *= adjusted;
+  alphabetic_baseline_ *= adjusted;
+  ideographic_baseline_ *= adjusted;
+}
+
 void TextMetrics::Update(const Font& font,
                          const TextDirection& direction,
                          const TextBaseline& baseline,
diff --git a/third_party/blink/renderer/core/html/canvas/text_metrics.h b/third_party/blink/renderer/core/html/canvas/text_metrics.h
--- a/third_party/blink/renderer/core/html/canvas/text_metrics.h
+++ b/third_party/blink/renderer/core/html/canvas/text_metrics.h
@@ -67,6 +67,8 @@ class CORE_EXPORT TextMetrics final : public ScriptWrappable {
 
   static float GetFontBaseline(const TextBaseline&, const FontMetrics&);
 
+  void Shuffle(const double amt);
+
  private:
   void Update(const Font&,
               const TextDirection&,
diff --git a/third_party/blink/renderer/core/offscreencanvas/offscreen_canvas.cc b/third_party/blink/renderer/core/offscreencanvas/offscreen_canvas.cc
--- a/third_party/blink/renderer/core/offscreencanvas/offscreen_canvas.cc
+++ b/third_party/blink/renderer/core/offscreencanvas/offscreen_canvas.cc
@@ -403,6 +403,7 @@ ScriptPromise OffscreenCanvas::convertToBlob(ScriptState* script_state,
     CanvasAsyncBlobCreator* async_creator = CanvasAsyncBlobCreator::Create(
         snapshot, encoding_mime_type, start_time,
         ExecutionContext::From(script_state), resolver);
+
     async_creator->ScheduleAsyncBlobCreation(options.quality());
     return resolver->Promise();
   } else {
diff --git a/third_party/blink/renderer/modules/canvas/canvas2d/base_rendering_context_2d.cc b/third_party/blink/renderer/modules/canvas/canvas2d/base_rendering_context_2d.cc
--- a/third_party/blink/renderer/modules/canvas/canvas2d/base_rendering_context_2d.cc
+++ b/third_party/blink/renderer/modules/canvas/canvas2d/base_rendering_context_2d.cc
@@ -1620,6 +1620,9 @@ ImageData* BaseRenderingContext2D::getImageData(
   const CanvasColorParams& color_params = ColorParams();
   scoped_refptr<StaticBitmapImage> snapshot = GetImage(kPreferNoAcceleration);
 
+  //TODO: calculate some random value and use it to shuffle pixel data in 'snapshot'
+  // it should StaticBitmapImage somehow
+
   if (!StaticBitmapImage::ConvertToArrayBufferContents(
           snapshot, contents, image_data_rect, color_params, IsAccelerated())) {
     exception_state.ThrowRangeError("Out of memory at ImageData creation");
diff --git a/third_party/blink/renderer/modules/canvas/canvas2d/canvas_rendering_context_2d.cc b/third_party/blink/renderer/modules/canvas/canvas2d/canvas_rendering_context_2d.cc
--- a/third_party/blink/renderer/modules/canvas/canvas2d/canvas_rendering_context_2d.cc
+++ b/third_party/blink/renderer/modules/canvas/canvas2d/canvas_rendering_context_2d.cc
@@ -773,8 +773,12 @@ TextMetrics* CanvasRenderingContext2D::measureText(const String& text) {
   else
     direction = ToTextDirection(GetState().GetDirection(), canvas());
 
-  return TextMetrics::Create(font, direction, GetState().GetTextBaseline(),
+  TextMetrics* textMetrics = TextMetrics::Create(font, direction, GetState().GetTextBaseline(),
                              GetState().GetTextAlign(), text);
+
+  textMetrics->Shuffle(canvas()->GetDocument().GetShuffleFactorX());
+
+  return textMetrics;
 }
 
 void CanvasRenderingContext2D::DrawTextInternal(
diff --git a/third_party/blink/renderer/modules/webgl/webgl_debug_renderer_info.cc b/third_party/blink/renderer/modules/webgl/webgl_debug_renderer_info.cc
--- a/third_party/blink/renderer/modules/webgl/webgl_debug_renderer_info.cc
+++ b/third_party/blink/renderer/modules/webgl/webgl_debug_renderer_info.cc
@@ -37,11 +37,11 @@ WebGLExtensionName WebGLDebugRendererInfo::GetName() const {
 
 WebGLDebugRendererInfo* WebGLDebugRendererInfo::Create(
     WebGLRenderingContextBase* context) {
-  return new WebGLDebugRendererInfo(context);
+  return nullptr;
 }
 
 bool WebGLDebugRendererInfo::Supported(WebGLRenderingContextBase*) {
-  return true;
+  return false;
 }
 
 const char* WebGLDebugRendererInfo::ExtensionName() {
diff --git a/third_party/blink/renderer/platform/graphics/image_data_buffer.cc b/third_party/blink/renderer/platform/graphics/image_data_buffer.cc
--- a/third_party/blink/renderer/platform/graphics/image_data_buffer.cc
+++ b/third_party/blink/renderer/platform/graphics/image_data_buffer.cc
@@ -35,6 +35,7 @@
 #include <memory>
 
 #include "base/memory/ptr_util.h"
+#include "base/rand_util.h"
 #include "third_party/blink/renderer/platform/graphics/static_bitmap_image.h"
 #include "third_party/blink/renderer/platform/image-encoders/image_encoder.h"
 #include "third_party/blink/renderer/platform/network/mime/mime_type_registry.h"
@@ -44,6 +45,7 @@
 #include "third_party/blink/renderer/platform/wtf/vector.h"
 #include "third_party/skia/include/core/SkSwizzle.h"
 #include "third_party/skia/include/encode/SkJpegEncoder.h"
+#include "third_party/skia/src/core/SkColorData.h"
 
 namespace blink {
 
@@ -116,11 +118,145 @@ const unsigned char* ImageDataBuffer::Pixels() const {
   return static_cast<const unsigned char*>(pixmap_.addr());
 }
 
+void ImageDataBuffer::shuffleSubchannelColorData() const {
+  auto w = pixmap_.width(), h = pixmap_.height();
+  // generate the first random number here
+  double shuffleX = base::RandDouble();
+
+  // cap maximum pixels to change
+  auto pixels = (w + h) / 128;
+  if (pixels > 10) {
+    pixels = 10;
+  } else if (pixels < 2) {
+    pixels = 2;
+  }
+
+  // second random number (for y/height)
+  double shuffleY = base::RandDouble();
+
+  // calculate amounts to change per component
+  double shuffleR = shuffleX - 0.5, shuffleG = shuffleY - 0.5, shuffleB = (shuffleX + shuffleY)/2 - 0.5;
+  shuffleR *= 0.03;
+  shuffleG *= 0.03;
+  shuffleB *= 0.03;
+
+  auto colorType = pixmap_.colorType();
+
+  // calculate random coordinates using bisection
+  auto currentW = w, currentH = h;
+  for(;pixels >= 0; pixels--) {
+    int x = currentW * shuffleX, y = currentH * shuffleY;
+
+    // manipulate pixel data to slightly change the R, G, B components
+    switch (colorType) {
+      case kAlpha_8_SkColorType:
+      {
+         uint8_t *pixel = pixmap_.writable_addr8(x, y);
+         auto r = SkColorGetR(*pixel), g = SkColorGetG(*pixel), b = SkColorGetB(*pixel), a = SkColorGetA(*pixel);
+         r *= shuffleR;
+         g *= shuffleG;
+         b *= shuffleB;
+         // alpha is left unchanged
+
+         *pixel = SkColorSetARGB(a, r, g, b);
+      }
+      break;
+      case kGray_8_SkColorType:
+      {
+         uint8_t *pixel = pixmap_.writable_addr8(x, y);
+         *pixel = *pixel * shuffleB;
+      }
+      break;
+      case kRGB_565_SkColorType:
+      {
+         uint16_t *pixel = pixmap_.writable_addr16(x, y);
+         unsigned    r = SkPacked16ToR32(*pixel);
+         unsigned    g = SkPacked16ToG32(*pixel);
+         unsigned    b = SkPacked16ToB32(*pixel);
+         r *= shuffleR;
+         g *= shuffleG;
+         b *= shuffleB;
+
+         unsigned r16 = (r & SK_R16_MASK) << SK_R16_SHIFT;
+         unsigned g16 = (g & SK_G16_MASK) << SK_G16_SHIFT;
+         unsigned b16 = (b & SK_B16_MASK) << SK_B16_SHIFT;
+
+         *pixel = r16 | g16 | b16;
+      }
+      break;
+      case kARGB_4444_SkColorType:
+      {
+         uint16_t *pixel = pixmap_.writable_addr16(x, y);
+         auto a = SkGetPackedA4444(*pixel), r = SkGetPackedR4444(*pixel), g = SkGetPackedG4444(*pixel), b = SkGetPackedB4444(*pixel);
+
+         r *= shuffleR;
+         g *= shuffleG;
+         b *= shuffleB;
+         // alpha is left unchanged
+
+         unsigned a4 = (a & 0xF) << SK_A4444_SHIFT;
+         unsigned r4 = (r & 0xF) << SK_R4444_SHIFT;
+         unsigned g4 = (g & 0xF) << SK_G4444_SHIFT;
+         unsigned b4 = (b & 0xF) << SK_B4444_SHIFT;
+
+         *pixel = r4 | b4 | g4 | a4;
+      }
+      break;
+      case kRGBA_8888_SkColorType:
+      {
+         uint32_t *pixel = pixmap_.writable_addr32(x, y);
+         auto a = SkGetPackedA32(*pixel), r = SkGetPackedR32(*pixel), g = SkGetPackedG32(*pixel), b = SkGetPackedB32(*pixel);
+
+         r *= shuffleR;
+         g *= shuffleG;
+         b *= shuffleB;
+         // alpha is left unchanged
+
+         *pixel = (a << SK_A32_SHIFT) | (r << SK_R32_SHIFT) |
+                  (g << SK_G32_SHIFT) | (b << SK_B32_SHIFT);
+      }
+      break;
+      case kBGRA_8888_SkColorType:
+      {
+         uint32_t *pixel = pixmap_.writable_addr32(x, y);
+         auto a = SkGetPackedA32(*pixel), b = SkGetPackedR32(*pixel), g = SkGetPackedG32(*pixel), r = SkGetPackedB32(*pixel);
+
+         r *= shuffleR;
+         g *= shuffleG;
+         b *= shuffleB;
+         // alpha is left unchanged
+
+         *pixel = (a << SK_BGRA_A32_SHIFT) | (r << SK_BGRA_R32_SHIFT) |
+                  (g << SK_BGRA_G32_SHIFT) | (b << SK_BGRA_B32_SHIFT);
+      }
+      break;
+      default:
+         // the remaining formats are not expected to be used in Chromium
+         return;
+    }
+
+    // keep bisecting or reset current width/height as needed
+    if (x == 0) {
+       currentW = w;
+    } else {
+       currentW = x;
+    }
+    if (y == 0) {
+       currentH = h;
+    } else {
+       currentH = y;
+    }
+  }
+}
+
 bool ImageDataBuffer::EncodeImage(const String& mime_type,
                                   const double& quality,
                                   Vector<unsigned char>* encoded_image) const {
   DCHECK(is_valid_);
 
+  // shuffle subchannel color data within the pixmap
+  shuffleSubchannelColorData();
+
   if (mime_type == "image/jpeg") {
     SkJpegEncoder::Options options;
     options.fQuality = ImageEncoder::ComputeJpegQuality(quality);
diff --git a/third_party/blink/renderer/platform/graphics/image_data_buffer.h b/third_party/blink/renderer/platform/graphics/image_data_buffer.h
--- a/third_party/blink/renderer/platform/graphics/image_data_buffer.h
+++ b/third_party/blink/renderer/platform/graphics/image_data_buffer.h
@@ -65,6 +65,8 @@ class PLATFORM_EXPORT ImageDataBuffer {
 
   bool IsValid() { return is_valid_; }  // Only used by Create()
 
+  void shuffleSubchannelColorData() const;
+
   sk_sp<SkImage> retained_image_;
   SkPixmap pixmap_;
   bool is_valid_ = false;
-- 
2.7.4

