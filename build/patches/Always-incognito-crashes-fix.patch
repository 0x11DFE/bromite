From: csagan5 <32685696+csagan5@users.noreply.github.com>
Date: Sun, 19 Apr 2020 16:16:43 +0200
Subject: Always-incognito crashes fix

Credits to @uazo for the crashes fixes

---
 .../chromium/chrome/browser/ChromeTabbedActivity.java | 11 +++++------
 .../org/chromium/chrome/browser/IntentHandler.java    |  6 +++++-
 2 files changed, 10 insertions(+), 7 deletions(-)

diff --git a/chrome/android/java/src/org/chromium/chrome/browser/ChromeTabbedActivity.java b/chrome/android/java/src/org/chromium/chrome/browser/ChromeTabbedActivity.java
--- a/chrome/android/java/src/org/chromium/chrome/browser/ChromeTabbedActivity.java
+++ b/chrome/android/java/src/org/chromium/chrome/browser/ChromeTabbedActivity.java
@@ -1373,12 +1373,6 @@ public class ChromeTabbedActivity extends ChromeActivity {
                     openNewTab(url, referer, headers, externalAppId, intent, true);
                     break;
                 case TabOpenType.OPEN_NEW_INCOGNITO_TAB:
-                    if (!TextUtils.equals(externalAppId, getPackageName())) {
-                        assert false : "Only Chrome is allowed to open incognito tabs";
-                        Log.e(TAG, "Only Chrome is allowed to open incognito tabs");
-                        return;
-                    }
-
                     if (!IncognitoUtils.isIncognitoModeEnabled()) {
                         // The incognito launcher shortcut is manipulated in #onDeferredStartup(),
                         // so it's possible for a user to invoke the shortcut before it's disabled.
@@ -1990,6 +1984,11 @@ public class ChromeTabbedActivity extends ChromeActivity {
                 }
             }
 
+            if (ContextUtils.getAppSharedPreferences().getBoolean(AlwaysIncognitoLinkInterceptor.PREF_ALWAYS_INCOGNITO, false)) {
+                return getTabCreator(true).launchUrlFromExternalApp(url, referer, headers,
+                        externalAppId, forceNewTab, intent, mIntentHandlingTimeMs);
+            }
+
             return getTabCreator(false).launchUrlFromExternalApp(url, referer, headers,
                     externalAppId, forceNewTab, intent, mIntentHandlingTimeMs);
         }
diff --git a/chrome/android/java/src/org/chromium/chrome/browser/IntentHandler.java b/chrome/android/java/src/org/chromium/chrome/browser/IntentHandler.java
--- a/chrome/android/java/src/org/chromium/chrome/browser/IntentHandler.java
+++ b/chrome/android/java/src/org/chromium/chrome/browser/IntentHandler.java
@@ -56,6 +56,8 @@ import org.chromium.net.HttpUtil;
 import org.chromium.network.mojom.ReferrerPolicy;
 import org.chromium.ui.base.PageTransition;
 
+import org.chromium.chrome.browser.AlwaysIncognitoLinkInterceptor;
+
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.util.ArrayList;
@@ -1033,7 +1035,9 @@ public class IntentHandler {
                     intent, ShortcutHelper.REUSE_URL_MATCHING_TAB_ELSE_NEW_TAB, false)) {
             return TabOpenType.REUSE_URL_MATCHING_TAB_ELSE_NEW_TAB;
         }
-        if (IntentUtils.safeGetBooleanExtra(intent, EXTRA_OPEN_NEW_INCOGNITO_TAB, false)) {
+        if (IntentUtils.safeGetBooleanExtra(intent, EXTRA_OPEN_NEW_INCOGNITO_TAB, false) ||
+            // always open a new tab if always-incognito is enabled
+            ContextUtils.getAppSharedPreferences().getBoolean(AlwaysIncognitoLinkInterceptor.PREF_ALWAYS_INCOGNITO, false)) {
             return TabOpenType.OPEN_NEW_INCOGNITO_TAB;
         }
         if (IntentUtils.safeGetIntExtra(
-- 
2.17.1

